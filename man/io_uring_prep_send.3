.\" Copyright (C) 2022 Jens Axboe <axboe@kernel.dk>
.\"
.\" SPDX-License-Identifier: LGPL-2.0-or-later
.\"
.TH io_uring_prep_send 3 "March 12, 2022" "liburing-2.2" "liburing Manual"
.SH NAME
io_uring_prep_send \- prepare a send request
.SH SYNOPSIS
.nf
.B #include <liburing.h>
.PP
.BI "void io_uring_prep_send(struct io_uring_sqe *" sqe ","
.BI "                        int " sockfd ","
.BI "                        const void *" buf ","
.BI "                        size_t " len ","
.BI "                        int " flags ");"
.PP
.BI "void io_uring_prep_sendto(struct io_uring_sqe *" sqe ","
.BI "                          int " sockfd ","
.BI "                          const void *" buf ","
.BI "                          size_t " len ","
.BI "                          int " flags ","
.BI "                          const struct sockaddr *" addr ","
.BI "                          socklen_t " addrlen ");"
.PP
.BI "void io_uring_prep_send_bundle(struct io_uring_sqe *" sqe ","
.BI "                               int " sockfd ","
.BI "                               size_t " len ","
.BI "                               int " flags ");"
.fi
.SH DESCRIPTION
.PP
The
.BR io_uring_prep_send (3)
function prepares a send request. The submission queue entry
.I sqe
is setup to use the file descriptor
.I sockfd
to start sending the data from
.I buf
of size
.I len
bytes and with modifier flags
.IR flags .
.PP
After calling this function, additional io_uring internal modifier flags
may be set in the SQE
.I ioprio
field. The following flags are supported:
.TP
.B IORING_RECVSEND_POLL_FIRST
If set, io_uring will assume the socket is currently full and attempting to
send data will be unsuccessful. For this case, io_uring will arm internal
poll and trigger a send of the data when the socket has space available.
If poll does indicate that space is available in the socket, the operation
will proceed immediately.

.TP
.B IORING_RECVSEND_BUNDLE
If set, the send operation will attempt to fill multiple buffers with rather than
just pick a single buffer to fill. To send multiple buffers in a single
send, the buffer group ID set in the SQE must be of the ring provided type.
If set, the CQE
.I res
field indicates the total number of bytes sent, and the buffer ID returned
in the CQE
.I flags
field indicates the first buffer in the send operation. The application must
process the indicated initial buffer ID and until all
.I res
bytes have been seen to know which is the last buffer in the send operation.
The buffers consumed will be contiguous from the initial buffer, in the order
in which they appear in the buffer ring. The CQE struct does not contain
the position of the buffer in the buffer ring, therefore in order to identify
buffers contained by the bundle, it is advised to maintain the cached head
index per buffer ring. This uint16_t index represents the position of the next
buffer to be consumed within the ring. Upon completion of a bundle send operation,
the cached head index should be incremented accordingly.
Sending in bundles can improve performance when more than one chunk of
data is available by eliminating redundant round trips through the networking
stack.
.TP
.B IORING_SEND_VECTORIZED
If set,
.I addr must point to an array of
.I struct iovec
and
.I len
must be the number of vectors in that array. This enables use of vectorized IO
for a normal send operation, rather than needing a sendmsg variant to
accomplish that.
.P

Note that using
.B IOSQE_IO_LINK
with this request type requires the setting of
.B MSG_WAITALL
in the
.IR flags
argument, as a short send isn't a considered an error condition without
that being set.
.PP
This function prepares an async
.BR send (2)
request. See that man page for details.
.PP
The
.BR io_uring_prep_sendto (3)
function prepares a sendto request. The submission queue entry
.I sqe
is setup to use the file descriptor
.I sockfd
to start sending the data from
.I buf
of size
.I len
bytes and with modifier flags
.IR flags .
The destination address is specified by
.I addr
and
.I addrlen
and must be a valid address for the socket type.
.PP
This function prepares an async
.BR sendto (2)
request. See that man page for details.
.PP
Both of the above send variants may be used with provided buffers, where rather
than pass a buffer in directly with the request,
.B IOSQE_BUFFER_SELECT
is set in the SQE
.I flags
field, and additionally a buffer group ID is set in the SQE
.I buf_group
field. By using provided buffers with send requests, the application can
prevent any kind of reordering of the outgoing data which can otherwise
occur if the application has more than one send request inflight for a single
socket. This provides better pipelining of data, where previously the app
needed to manually serialize sends.
.PP
The bundle version allows the application to issue a single send request,
with a buffer group ID given in the SQE
.I buf_group
field, which keeps sending from that buffer group until it runs out of buffers.
As with any other request using provided buffers,
.B IOSQE_BUFFER_SELECT
must also be set in the SQE
.I flags
before submission. Currently
.I len
must be given as
.B 0
otherwise the request will be errored with
.B -EINVAL
as the result code. Future versions may allow setting
.I
to limit the transfer size. A single CQE is posted for the send, with the result
being how many bytes were sent, on success. When used with provided buffers,
send or send bundle will contain the starting buffer group ID in the CQE
.I flags
field. The number of bytes sent starts from there, and will be in contiguous
buffer IDs after that. Send bundle, and send with provided buffers in general,
are available since kernel 6.10, and can be further identified by checking for
the
.B IORING_FEAT_SEND_BUF_SELECT
flag returned in when using
.BR io_uring_queue_init_params (3)
to setup the ring.

.SH RETURN VALUE
None
.SH ERRORS
The CQE
.I res
field will contain the result of the operation. On success, it contains
the number of bytes sent, which may be less than
.I len
(a short send). On error, it contains the negated
.I errno
value.
.PP
Common errors include:
.TP
.B -ECONNRESET
Connection reset by peer.
.TP
.B -EPIPE
The socket has been shut down for writing or is not connected.
.TP
.B -EAGAIN
The socket is non-blocking and the send would block. Consider using
.B IORING_RECVSEND_POLL_FIRST
to handle this automatically.
.TP
.B -ENOTCONN
The socket is not connected (for connection-oriented sockets).
.SH EXAMPLE
.SS Basic TCP send
.EX
#include <stdio.h>
#include <string.h>
#include <liburing.h>

int send_data(struct io_uring *ring, int sockfd,
              const void *data, size_t len)
{
    struct io_uring_sqe *sqe;
    struct io_uring_cqe *cqe;
    int ret;

    sqe = io_uring_get_sqe(ring);
    io_uring_prep_send(sqe, sockfd, data, len, 0);

    ret = io_uring_submit(ring);
    if (ret < 0)
        return ret;

    ret = io_uring_wait_cqe(ring, &cqe);
    if (ret < 0)
        return ret;

    ret = cqe->res;
    io_uring_cqe_seen(ring, cqe);

    if (ret < 0) {
        fprintf(stderr, "send failed: %d\\n", ret);
        return ret;
    }

    printf("Sent %d bytes\\n", ret);
    return ret;
}
.EE
.SS UDP sendto with destination address
.EX
#include <stdio.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <liburing.h>

int send_udp(struct io_uring *ring, int sockfd,
             const void *data, size_t len,
             const char *dest_ip, int dest_port)
{
    struct io_uring_sqe *sqe;
    struct io_uring_cqe *cqe;
    struct sockaddr_in addr;
    int ret;

    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = htons(dest_port);
    inet_pton(AF_INET, dest_ip, &addr.sin_addr);

    sqe = io_uring_get_sqe(ring);
    io_uring_prep_sendto(sqe, sockfd, data, len, 0,
                         (struct sockaddr *)&addr, sizeof(addr));

    io_uring_submit(ring);
    io_uring_wait_cqe(ring, &cqe);

    ret = cqe->res;
    io_uring_cqe_seen(ring, cqe);

    return ret;
}
.EE
.SS Using POLL_FIRST for non-blocking sends
.EX
#include <liburing.h>

/*
 * Send with automatic polling - useful when the socket
 * might not be ready for writing immediately.
 */
void send_with_poll(struct io_uring *ring, int sockfd,
                    const void *data, size_t len)
{
    struct io_uring_sqe *sqe;

    sqe = io_uring_get_sqe(ring);
    io_uring_prep_send(sqe, sockfd, data, len, 0);

    /* Let io_uring handle polling if socket isn't ready */
    sqe->ioprio |= IORING_RECVSEND_POLL_FIRST;

    io_uring_submit(ring);
}
.EE
.SS Linked send with MSG_WAITALL
.EX
#include <sys/socket.h>
#include <liburing.h>

/*
 * When linking requests, use MSG_WAITALL to ensure
 * short sends are treated as errors and break the chain.
 */
int linked_send_recv(struct io_uring *ring, int sockfd,
                     const void *sendbuf, size_t sendlen,
                     void *recvbuf, size_t recvlen)
{
    struct io_uring_sqe *sqe;
    struct io_uring_cqe *cqe;
    int ret;

    /* Send with MSG_WAITALL - required for linking */
    sqe = io_uring_get_sqe(ring);
    io_uring_prep_send(sqe, sockfd, sendbuf, sendlen, MSG_WAITALL);
    sqe->flags |= IOSQE_IO_LINK;
    io_uring_sqe_set_data64(sqe, 1);

    /* Linked receive */
    sqe = io_uring_get_sqe(ring);
    io_uring_prep_recv(sqe, sockfd, recvbuf, recvlen, 0);
    io_uring_sqe_set_data64(sqe, 2);

    io_uring_submit(ring);

    /* Collect both completions */
    for (int i = 0; i < 2; i++) {
        io_uring_wait_cqe(ring, &cqe);

        if (io_uring_cqe_get_data64(cqe) == 1 && cqe->res < 0)
            ret = cqe->res;
        else if (io_uring_cqe_get_data64(cqe) == 2)
            ret = cqe->res;

        io_uring_cqe_seen(ring, cqe);
    }

    return ret;
}
.EE
.SS Handling short sends
.EX
#include <stdio.h>
#include <liburing.h>

/*
 * Send all data, handling short sends by retrying.
 */
int send_all(struct io_uring *ring, int sockfd,
             const void *buf, size_t len)
{
    struct io_uring_sqe *sqe;
    struct io_uring_cqe *cqe;
    const char *data = buf;
    size_t remaining = len;
    int ret;

    while (remaining > 0) {
        sqe = io_uring_get_sqe(ring);
        io_uring_prep_send(sqe, sockfd, data, remaining, 0);

        io_uring_submit(ring);
        io_uring_wait_cqe(ring, &cqe);

        ret = cqe->res;
        io_uring_cqe_seen(ring, cqe);

        if (ret < 0)
            return ret;  /* Error */
        if (ret == 0)
            return -ECONNRESET;  /* Connection closed */

        data += ret;
        remaining -= ret;
    }

    return len;
}
.EE
.SS Batch send multiple messages
.EX
#include <stdio.h>
#include <liburing.h>

struct send_request {
    const void *buf;
    size_t len;
    int result;
};

/*
 * Send multiple buffers in parallel.
 */
int batch_send(struct io_uring *ring, int sockfd,
               struct send_request *reqs, int count)
{
    struct io_uring_sqe *sqe;
    struct io_uring_cqe *cqe;
    int i, ret;

    /* Queue all sends */
    for (i = 0; i < count; i++) {
        sqe = io_uring_get_sqe(ring);
        io_uring_prep_send(sqe, sockfd, reqs[i].buf, reqs[i].len, 0);
        io_uring_sqe_set_data(sqe, &reqs[i]);
    }

    ret = io_uring_submit(ring);
    if (ret < 0)
        return ret;

    /* Collect results */
    for (i = 0; i < count; i++) {
        io_uring_wait_cqe(ring, &cqe);

        struct send_request *req = io_uring_cqe_get_data(cqe);
        req->result = cqe->res;

        io_uring_cqe_seen(ring, cqe);
    }

    return 0;
}
.EE
.SS Send with provided buffers for ordering
.EX
#include <liburing.h>

#define BGID 1

/*
 * Using provided buffers with send ensures proper ordering
 * of data when multiple sends are in flight on same socket.
 */
void send_ordered(struct io_uring *ring, int sockfd, int bgid)
{
    struct io_uring_sqe *sqe;

    sqe = io_uring_get_sqe(ring);
    /* Zero-length prep, kernel picks buffer from ring */
    io_uring_prep_send(sqe, sockfd, NULL, 0, 0);
    sqe->flags |= IOSQE_BUFFER_SELECT;
    sqe->buf_group = bgid;

    io_uring_submit(ring);
}
.EE
.SH NOTES
When using
.B IOSQE_IO_LINK
to chain send with other operations, always include
.B MSG_WAITALL
in the flags. Without it, a short send is not considered an error and the chain
will continue, which may not be the desired behavior.
.PP
For high-throughput applications with multiple sends in flight on the same socket,
consider using provided buffers with send. This ensures proper ordering of outgoing
data without requiring manual serialization at the application level.
.PP
The
.B IORING_RECVSEND_POLL_FIRST
flag is useful when the socket might not be ready for writing. Instead of
returning
.B -EAGAIN
immediately, io_uring will poll the socket and complete the send when ready.
This is more efficient than the application handling EAGAIN and retrying.
.SH SEE ALSO
.BR io_uring_get_sqe (3),
.BR io_uring_submit (3),
.BR io_uring_prep_recv (3),
.BR io_uring_buf_ring_init (3),
.BR io_uring_buf_ring_add (3),
.BR send (2),
.BR sendto (2)
