.\" Copyright (C) 2022 Jens Axboe <axboe@kernel.dk>
.\"
.\" SPDX-License-Identifier: LGPL-2.0-or-later
.\"
.TH io_uring_prep_renameat 3 "March 13, 2022" "liburing-2.2" "liburing Manual"
.SH NAME
io_uring_prep_renameat \- prepare a renameat request
.SH SYNOPSIS
.nf
.B #include <fcntl.h>
.B #include <stdio.h>
.B #include <liburing.h>
.PP
.BI "void io_uring_prep_renameat(struct io_uring_sqe *" sqe ","
.BI "                            int " olddirfd ","
.BI "                            const char *" oldpath ","
.BI "                            int " newdirfd ","
.BI "                            const char *" newpath ","
.BI "                            unsigned int " flags ");"
.PP
.BI "void io_uring_prep_rename(struct io_uring_sqe *" sqe ","
.BI "                          const char *" oldpath ","
.BI "                          const char *" newpath ");"
.fi
.SH DESCRIPTION
.PP
The
.BR io_uring_prep_renameat (3)
function prepares a renameat request. The submission queue entry
.I sqe
is setup to use the old directory file descriptor pointed to by
.I olddirfd
and old path pointed to by
.I oldpath
with the new directory file descriptor pointed to by
.I newdirfd
and the new path pointed to by
.I newpath
and using the specified flags in
.IR flags .

The
.BR io_uring_prep_rename (3)
function prepares a rename request. The submission queue entry
.I sqe
is setup to use the old path pointed to by
.I oldpath
with the new path pointed to by
.IR newpath ,
both relative to the current working directory and using the specified flags in
.IR flags .

These functions prepare an async
.BR renameat2 (2)
or
.BR rename (2)
request. If
.I flags
is zero, then this call is similar to the
.BR renameat (2)
system call. See those man pages for details.

.SH RETURN VALUE
None
.SH ERRORS
The CQE
.I res
field will contain the result of the operation. On success, it contains
.BR 0 .
On error, it contains the negated
.I errno
value.
.PP
Common errors include:
.TP
.B -ENOENT
The source file does not exist.
.TP
.B -EACCES
Permission denied.
.TP
.B -EEXIST
The target already exists and
.B RENAME_NOREPLACE
was specified.
.TP
.B -EISDIR
The target is a directory but the source is not.
.TP
.B -ENOTDIR
A component of the path prefix is not a directory.
.TP
.B -EXDEV
Source and target are on different filesystems (rename cannot cross mounts).
.TP
.B -ENOTEMPTY
The target is a non-empty directory.
.TP
.B -EINVAL
Invalid flags were specified (e.g., both
.B RENAME_NOREPLACE
and
.B RENAME_EXCHANGE
together).
.SH NOTES
As with any request that passes in data in a struct, that data must remain
valid until the request has been successfully submitted. It need not remain
valid until completion. Once a request has been submitted, the in-kernel
state is stable. Very early kernels (5.4 and earlier) required state to be
stable until the completion occurred. Applications can test for this
behavior by inspecting the
.B IORING_FEAT_SUBMIT_STABLE
flag passed back from
.BR io_uring_queue_init_params (3).
.PP
Useful flags for renameat2:
.IP \(bu 2
.B RENAME_NOREPLACE
- Don't overwrite target if it exists
.IP \(bu 2
.B RENAME_EXCHANGE
- Atomically exchange source and target
.IP \(bu 2
.B RENAME_WHITEOUT
- Create a whiteout at the source (overlay filesystems)
.SH EXAMPLE
.SS Basic file rename
.EX
#include <stdio.h>
#include <liburing.h>

int rename_file(struct io_uring *ring,
                const char *oldpath, const char *newpath)
{
    struct io_uring_sqe *sqe;
    struct io_uring_cqe *cqe;
    int ret;

    sqe = io_uring_get_sqe(ring);
    io_uring_prep_rename(sqe, oldpath, newpath);

    ret = io_uring_submit(ring);
    if (ret < 0)
        return ret;

    ret = io_uring_wait_cqe(ring, &cqe);
    if (ret < 0)
        return ret;

    ret = cqe->res;
    io_uring_cqe_seen(ring, cqe);

    if (ret < 0)
        fprintf(stderr, "rename failed: %d\\n", ret);

    return ret;
}
.EE
.SS Rename with NOREPLACE (don't overwrite)
.EX
#include <stdio.h>
#include <fcntl.h>
#include <linux/fs.h>
#include <liburing.h>

/*
 * Rename file only if target doesn't exist.
 * Returns -EEXIST if target already exists.
 */
int rename_noreplace(struct io_uring *ring,
                     const char *oldpath, const char *newpath)
{
    struct io_uring_sqe *sqe;
    struct io_uring_cqe *cqe;
    int ret;

    sqe = io_uring_get_sqe(ring);
    io_uring_prep_renameat(sqe, AT_FDCWD, oldpath,
                           AT_FDCWD, newpath,
                           RENAME_NOREPLACE);

    io_uring_submit(ring);
    io_uring_wait_cqe(ring, &cqe);

    ret = cqe->res;
    io_uring_cqe_seen(ring, cqe);

    if (ret == -EEXIST)
        fprintf(stderr, "Target already exists\\n");

    return ret;
}
.EE
.SS Atomic file swap with RENAME_EXCHANGE
.EX
#include <stdio.h>
#include <fcntl.h>
#include <linux/fs.h>
#include <liburing.h>

/*
 * Atomically swap two files. Useful for safe config updates:
 * write new config to temp file, then swap with original.
 */
int swap_files(struct io_uring *ring,
               const char *path1, const char *path2)
{
    struct io_uring_sqe *sqe;
    struct io_uring_cqe *cqe;
    int ret;

    sqe = io_uring_get_sqe(ring);
    io_uring_prep_renameat(sqe, AT_FDCWD, path1,
                           AT_FDCWD, path2,
                           RENAME_EXCHANGE);

    io_uring_submit(ring);
    io_uring_wait_cqe(ring, &cqe);

    ret = cqe->res;
    io_uring_cqe_seen(ring, cqe);

    return ret;
}

/*
 * Safe config file update pattern:
 * 1. Write new config to .new file
 * 2. Swap .new with current config
 * 3. Delete old config (now at .new)
 */
int safe_config_update(struct io_uring *ring,
                       const char *config_path,
                       const void *new_data, size_t len)
{
    char new_path[256];
    int fd, ret;

    snprintf(new_path, sizeof(new_path), "%s.new", config_path);

    /* Write new config */
    fd = open(new_path, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    write(fd, new_data, len);
    fsync(fd);
    close(fd);

    /* Atomically swap */
    ret = swap_files(ring, new_path, config_path);
    if (ret == 0) {
        /* Success - remove old config (now at .new) */
        unlink(new_path);
    }

    return ret;
}
.EE
.SS Rename relative to directory
.EX
#include <stdio.h>
#include <fcntl.h>
#include <liburing.h>

/*
 * Rename files within a directory, using directory fd.
 * Useful for safely operating within a specific directory.
 */
int rename_in_dir(struct io_uring *ring, int dirfd,
                  const char *oldname, const char *newname)
{
    struct io_uring_sqe *sqe;
    struct io_uring_cqe *cqe;
    int ret;

    sqe = io_uring_get_sqe(ring);
    io_uring_prep_renameat(sqe, dirfd, oldname,
                           dirfd, newname, 0);

    io_uring_submit(ring);
    io_uring_wait_cqe(ring, &cqe);

    ret = cqe->res;
    io_uring_cqe_seen(ring, cqe);

    return ret;
}
.EE
.SS Batch rename multiple files
.EX
#include <stdio.h>
#include <liburing.h>

struct rename_op {
    const char *oldpath;
    const char *newpath;
};

int batch_rename(struct io_uring *ring,
                 struct rename_op *ops, int count)
{
    struct io_uring_sqe *sqe;
    struct io_uring_cqe *cqe;
    int i, ret, errors = 0;

    /* Queue all rename operations */
    for (i = 0; i < count; i++) {
        sqe = io_uring_get_sqe(ring);
        io_uring_prep_rename(sqe, ops[i].oldpath, ops[i].newpath);
        io_uring_sqe_set_data64(sqe, i);
    }

    ret = io_uring_submit(ring);
    if (ret < 0)
        return ret;

    /* Collect results */
    for (i = 0; i < count; i++) {
        io_uring_wait_cqe(ring, &cqe);

        if (cqe->res < 0) {
            int idx = io_uring_cqe_get_data64(cqe);
            fprintf(stderr, "rename %s -> %s failed: %d\\n",
                    ops[idx].oldpath, ops[idx].newpath, cqe->res);
            errors++;
        }

        io_uring_cqe_seen(ring, cqe);
    }

    return errors ? -1 : 0;
}
.EE
.SH SEE ALSO
.BR io_uring_get_sqe (3),
.BR io_uring_submit (3),
.BR io_uring_prep_unlinkat (3),
.BR renameat (2),
.BR renameat2 (2),
.BR rename (2)
