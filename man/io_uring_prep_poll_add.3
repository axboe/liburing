.\" Copyright (C) 2022 Jens Axboe <axboe@kernel.dk>
.\"
.\" SPDX-License-Identifier: LGPL-2.0-or-later
.\"
.TH io_uring_prep_poll_add 3 "March 12, 2022" "liburing-2.2" "liburing Manual"
.SH NAME
io_uring_prep_poll_add \- prepare a poll request
.SH SYNOPSIS
.nf
.B #include <poll.h>
.B #include <liburing.h>
.PP
.BI "void io_uring_prep_poll_add(struct io_uring_sqe *" sqe ","
.BI "                            int " fd ","
.BI "                            unsigned " poll_mask ");"
.PP
.BI "void io_uring_prep_poll_multishot(struct io_uring_sqe *" sqe ","
.BI "                                  int " fd ","
.BI "                                  unsigned " poll_mask ");"
.fi
.SH DESCRIPTION
.PP
The
.BR io_uring_prep_poll_add (3)
function prepares a poll request. The submission queue entry
.I sqe
is setup to use the file descriptor
.I fd
that should get polled, with the events desired specified in the
.I poll_mask
argument.

The default behavior is a single-shot poll request. When the specified event
has triggered, a completion CQE is posted and no more events will be generated
by the poll request.
.BR io_uring_prep_poll_multishot (3)
behaves identically in terms of events, but it persists across notifications
and will repeatedly post notifications for the same registration. A CQE
posted from a multishot poll request will have
.B IORING_CQE_F_MORE
set in the CQE
.I flags
member, indicating that the application should expect more completions from
this request. If the multishot poll request gets terminated or experiences
an error, this flag will not be set in the CQE. If this happens, the application
should not expect further CQEs from the original request and must reissue a
new one if it still wishes to get notifications on this file descriptor.

.SH RETURN VALUE
None
.SH ERRORS
The CQE
.I res
field will contain the result of the operation. On success, it is a bitmask
of the events that occurred (e.g.,
.BR POLLIN ,
.BR POLLOUT ,
.BR POLLERR ).
On error, it contains the negated
.I errno
value.
.PP
Common errors include:
.TP
.B -EBADF
The file descriptor is not valid.
.TP
.B -EINVAL
The poll_mask contains invalid flags.
.TP
.B -ECANCELED
The poll request was canceled.
.PP
Note that
.B POLLHUP
and
.B POLLERR
may be returned even if not requested, as they indicate exceptional
conditions on the file descriptor.
.SH NOTES
Poll requests are particularly useful for:
.IP \(bu 2
Waiting for socket readability/writability before issuing recv/send
.IP \(bu 2
Monitoring multiple file descriptors efficiently
.IP \(bu 2
Implementing event-driven servers without blocking
.PP
The multishot variant is ideal for long-lived connections where you need
continuous notification of events. It reduces overhead by avoiding the
need to resubmit poll requests after each event.
.PP
Unlike
.BR epoll (7),
io_uring poll does not require a separate file descriptor for the poll
set - the io_uring ring itself serves this purpose.
.SH EXAMPLE
.SS Basic poll for readability
.EX
#include <stdio.h>
#include <poll.h>
#include <liburing.h>

/*
 * Wait for a socket to become readable.
 */
int wait_readable(struct io_uring *ring, int fd)
{
    struct io_uring_sqe *sqe;
    struct io_uring_cqe *cqe;
    int ret;

    sqe = io_uring_get_sqe(ring);
    io_uring_prep_poll_add(sqe, fd, POLLIN);

    ret = io_uring_submit(ring);
    if (ret < 0)
        return ret;

    ret = io_uring_wait_cqe(ring, &cqe);
    if (ret < 0)
        return ret;

    ret = cqe->res;
    io_uring_cqe_seen(ring, cqe);

    if (ret < 0) {
        fprintf(stderr, "poll error: %d\\n", ret);
        return ret;
    }

    if (ret & POLLIN)
        printf("Socket is readable\\n");
    if (ret & POLLHUP)
        printf("Socket hung up\\n");
    if (ret & POLLERR)
        printf("Socket error\\n");

    return ret;
}
.EE
.SS Multishot poll for event-driven I/O
.EX
#include <stdio.h>
#include <poll.h>
#include <liburing.h>

#define POLL_SOCKET 1
#define READ_DATA   2

struct conn {
    int fd;
    char buf[4096];
};

void start_poll(struct io_uring *ring, struct conn *c)
{
    struct io_uring_sqe *sqe;

    sqe = io_uring_get_sqe(ring);
    io_uring_prep_poll_multishot(sqe, c->fd, POLLIN);
    io_uring_sqe_set_data(sqe, c);

    io_uring_submit(ring);
}

void handle_poll_event(struct io_uring *ring, struct conn *c,
                       struct io_uring_cqe *cqe)
{
    struct io_uring_sqe *sqe;

    if (cqe->res < 0) {
        fprintf(stderr, "poll error: %d\\n", cqe->res);
        return;
    }

    if (cqe->res & POLLIN) {
        /* Data available - issue a read */
        sqe = io_uring_get_sqe(ring);
        io_uring_prep_recv(sqe, c->fd, c->buf, sizeof(c->buf), 0);
        io_uring_sqe_set_data(sqe, c);
        io_uring_submit(ring);
    }

    if (cqe->res & (POLLHUP | POLLERR)) {
        printf("Connection closed or error\\n");
    }

    /* Check if multishot poll is still active */
    if (!(cqe->flags & IORING_CQE_F_MORE)) {
        printf("Multishot poll ended, restarting\\n");
        start_poll(ring, c);
    }
}
.EE
.SS Monitoring multiple file descriptors
.EX
#include <stdio.h>
#include <poll.h>
#include <liburing.h>

struct fd_info {
    int fd;
    int type;  /* Application-specific type */
};

/*
 * Set up multishot polls on multiple file descriptors.
 */
void monitor_fds(struct io_uring *ring, struct fd_info *fds, int count)
{
    struct io_uring_sqe *sqe;
    int i;

    for (i = 0; i < count; i++) {
        sqe = io_uring_get_sqe(ring);
        io_uring_prep_poll_multishot(sqe, fds[i].fd, POLLIN | POLLHUP);
        io_uring_sqe_set_data(sqe, &fds[i]);
    }

    io_uring_submit(ring);
}

void event_loop(struct io_uring *ring)
{
    struct io_uring_cqe *cqe;
    struct fd_info *info;

    while (1) {
        io_uring_wait_cqe(ring, &cqe);

        info = io_uring_cqe_get_data(cqe);
        printf("Event on fd %d (type %d): 0x%x\\n",
               info->fd, info->type, cqe->res);

        if (cqe->res & POLLIN) {
            handle_readable(info);
        }
        if (cqe->res & POLLHUP) {
            handle_disconnect(info);
        }

        /* Resubmit if multishot ended */
        if (!(cqe->flags & IORING_CQE_F_MORE)) {
            struct io_uring_sqe *sqe = io_uring_get_sqe(ring);
            io_uring_prep_poll_multishot(sqe, info->fd, POLLIN | POLLHUP);
            io_uring_sqe_set_data(sqe, info);
            io_uring_submit(ring);
        }

        io_uring_cqe_seen(ring, cqe);
    }
}
.EE
.SS Poll with timeout using linked requests
.EX
#include <stdio.h>
#include <poll.h>
#include <liburing.h>

/*
 * Wait for socket to be readable, with a timeout.
 */
int poll_with_timeout(struct io_uring *ring, int fd, int timeout_ms)
{
    struct io_uring_sqe *sqe;
    struct io_uring_cqe *cqe;
    struct __kernel_timespec ts;
    int ret, poll_result = 0;

    /* Submit poll with link to timeout */
    sqe = io_uring_get_sqe(ring);
    io_uring_prep_poll_add(sqe, fd, POLLIN);
    sqe->flags |= IOSQE_IO_LINK;
    io_uring_sqe_set_data64(sqe, 1);

    /* Linked timeout */
    sqe = io_uring_get_sqe(ring);
    ts.tv_sec = timeout_ms / 1000;
    ts.tv_nsec = (timeout_ms % 1000) * 1000000LL;
    io_uring_prep_link_timeout(sqe, &ts, 0);
    io_uring_sqe_set_data64(sqe, 2);

    io_uring_submit(ring);

    /* Collect both CQEs */
    for (int i = 0; i < 2; i++) {
        io_uring_wait_cqe(ring, &cqe);

        if (io_uring_cqe_get_data64(cqe) == 1) {
            poll_result = cqe->res;
        }

        io_uring_cqe_seen(ring, cqe);
    }

    if (poll_result == -ECANCELED)
        return -ETIMEDOUT;

    return poll_result;
}
.EE
.SH SEE ALSO
.BR io_uring_get_sqe (3),
.BR io_uring_submit (3),
.BR io_uring_prep_poll_remove (3),
.BR io_uring_prep_recv (3),
.BR poll (2),
.BR epoll_ctl (3)
