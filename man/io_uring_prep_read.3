.\" Copyright (C) 2021 Stefan Roesch <shr@fb.com>
.\"
.\" SPDX-License-Identifier: LGPL-2.0-or-later
.\"
.TH io_uring_prep_read 3 "November 15, 2021" "liburing-2.1" "liburing Manual"
.SH NAME
io_uring_prep_read \- prepare I/O read request
.SH SYNOPSIS
.nf
.B #include <liburing.h>
.PP
.BI "void io_uring_prep_read(struct io_uring_sqe *" sqe ","
.BI "                        int " fd ","
.BI "                        void *" buf ","
.BI "                        unsigned " nbytes ","
.BI "                        __u64 " offset ");"
.fi
.SH DESCRIPTION
.PP
The
.BR io_uring_prep_read (3)
function prepares an IO read request. The submission queue entry
.I sqe
is setup to use the file descriptor
.I fd
to start reading
.I nbytes
into the buffer
.I buf
at the specified
.IR offset .
.PP
This function prepares an async
.BR pread (2)
request. See that man page for details on the arguments specified to this
prep helper.
.PP
On files that support seeking, if the offset is set to
.BR -1 ,
the read operation commences at the file offset, and the file offset is
incremented by the number of bytes read. See
.BR read (2)
for more details. Note that for an async API, reading and updating the
current file offset may result in unpredictable behavior, unless access
to the file is serialized. It is not encouraged to use this feature, if it's
possible to provide the desired IO offset from the application or library.
.PP
On files that are not capable of seeking, the offset must be 0 or -1.
.PP
After the read has been prepared it can be submitted with one of the submit
functions.
.SH RETURN VALUE
None
.SH ERRORS
The CQE
.I res
field will contain the result of the operation. On success,
.I res
will contain the number of bytes read, which may be less than
.I nbytes
(a short read). On error,
.I res
contains a negative error code. Note that where synchronous system calls will return
.B -1
on failure and set
.I errno
to the actual error value, io_uring never uses
.IR errno .
Instead it returns the negated
.I errno
directly in the CQE
.I res
field.
.SH NOTES
Unless an application explicitly needs to pass in more than one iovec, it
is more efficient to use this function rather than
.BR io_uring_prep_readv (3).
.SH EXAMPLE
.EX
#include <stdio.h>
#include <fcntl.h>
#include <liburing.h>

int main(int argc, char *argv[])
{
    struct io_uring ring;
    struct io_uring_sqe *sqe;
    struct io_uring_cqe *cqe;
    char buf[4096];
    int fd, ret;

    if (argc < 2) {
        fprintf(stderr, "Usage: %s <file>\\n", argv[0]);
        return 1;
    }

    /* Initialize io_uring */
    ret = io_uring_queue_init(8, &ring, 0);
    if (ret) {
        fprintf(stderr, "io_uring_queue_init: %d\\n", ret);
        return 1;
    }

    /* Open the file */
    fd = open(argv[1], O_RDONLY);
    if (fd < 0) {
        perror("open");
        return 1;
    }

    /* Get an SQE and prepare a read request */
    sqe = io_uring_get_sqe(&ring);
    io_uring_prep_read(sqe, fd, buf, sizeof(buf), 0);

    /* Submit the request */
    ret = io_uring_submit(&ring);
    if (ret < 0) {
        fprintf(stderr, "io_uring_submit: %d\\n", ret);
        return 1;
    }

    /* Wait for completion */
    ret = io_uring_wait_cqe(&ring, &cqe);
    if (ret < 0) {
        fprintf(stderr, "io_uring_wait_cqe: %d\\n", ret);
        return 1;
    }

    /* Check the result */
    if (cqe->res < 0) {
        fprintf(stderr, "read failed: %d\\n", cqe->res);
    } else {
        printf("Read %d bytes\\n", cqe->res);
    }

    /* Mark CQE as seen */
    io_uring_cqe_seen(&ring, cqe);

    close(fd);
    io_uring_queue_exit(&ring);
    return 0;
}
.EE
.SH SEE ALSO
.BR io_uring_get_sqe (3),
.BR io_uring_prep_readv (3),
.BR io_uring_prep_readv2 (3),
.BR io_uring_submit (3),
.BR pread (2)
