.\" Copyright (C) 2021 Stefan Roesch <shr@fb.com>
.\"
.\" SPDX-License-Identifier: LGPL-2.0-or-later
.\"
.TH io_uring_prep_read 3 "November 15, 2021" "liburing-2.1" "liburing Manual"
.SH NAME
io_uring_prep_read \- prepare I/O read request
.SH SYNOPSIS
.nf
.B #include <liburing.h>
.PP
.BI "void io_uring_prep_read(struct io_uring_sqe *" sqe ","
.BI "                        int " fd ","
.BI "                        void *" buf ","
.BI "                        unsigned " nbytes ","
.BI "                        __u64 " offset ");"
.fi
.SH DESCRIPTION
.PP
The
.BR io_uring_prep_read (3)
function prepares an IO read request. The submission queue entry
.I sqe
is setup to use the file descriptor
.I fd
to start reading
.I nbytes
into the buffer
.I buf
at the specified
.IR offset .
.PP
This function prepares an async
.BR pread (2)
request. See that man page for details on the arguments specified to this
prep helper.
.PP
On files that support seeking, if the offset is set to
.BR -1 ,
the read operation commences at the file offset, and the file offset is
incremented by the number of bytes read. See
.BR read (2)
for more details. Note that for an async API, reading and updating the
current file offset may result in unpredictable behavior, unless access
to the file is serialized. It is not encouraged to use this feature, if it's
possible to provide the desired IO offset from the application or library.
.PP
On files that are not capable of seeking, the offset must be 0 or -1.
.PP
After the read has been prepared it can be submitted with one of the submit
functions.
.SH RETURN VALUE
None
.SH ERRORS
The CQE
.I res
field will contain the result of the operation. On success,
.I res
will contain the number of bytes read, which may be less than
.I nbytes
(a short read). On error,
.I res
contains a negative error code.
.PP
Common errors include:
.TP
.B -EBADF
Invalid file descriptor or file not open for reading.
.TP
.B -EFAULT
Buffer points to invalid memory.
.TP
.B -EINVAL
Invalid offset for this file type, or negative bytes count.
.TP
.B -EIO
I/O error occurred during the read.
.TP
.B -EISDIR
Attempted to read from a directory.
.SH NOTES
Unless an application explicitly needs to pass in more than one iovec, it
is more efficient to use this function rather than
.BR io_uring_prep_readv (3).
.PP
A return value of 0 indicates end-of-file (EOF). Short reads (returning fewer
bytes than requested) are common and should be handled by the application.
.PP
For regular files, reads can be done at any offset. For pipes, sockets, and
terminals, the offset must be 0 or -1.
.PP
Buffer selection using
.B IOSQE_BUFFER_SELECT
can be used with read operations to let the kernel pick a buffer from a
provided buffer pool. This is useful for server applications handling many
concurrent reads.
.SH EXAMPLE
.EX
#include <stdio.h>
#include <fcntl.h>
#include <liburing.h>

int main(int argc, char *argv[])
{
    struct io_uring ring;
    struct io_uring_sqe *sqe;
    struct io_uring_cqe *cqe;
    char buf[4096];
    int fd, ret;

    if (argc < 2) {
        fprintf(stderr, "Usage: %s <file>\\n", argv[0]);
        return 1;
    }

    /* Initialize io_uring */
    ret = io_uring_queue_init(8, &ring, 0);
    if (ret) {
        fprintf(stderr, "io_uring_queue_init: %d\\n", ret);
        return 1;
    }

    /* Open the file */
    fd = open(argv[1], O_RDONLY);
    if (fd < 0) {
        perror("open");
        return 1;
    }

    /* Get an SQE and prepare a read request */
    sqe = io_uring_get_sqe(&ring);
    io_uring_prep_read(sqe, fd, buf, sizeof(buf), 0);

    /* Submit the request */
    ret = io_uring_submit(&ring);
    if (ret < 0) {
        fprintf(stderr, "io_uring_submit: %d\\n", ret);
        return 1;
    }

    /* Wait for completion */
    ret = io_uring_wait_cqe(&ring, &cqe);
    if (ret < 0) {
        fprintf(stderr, "io_uring_wait_cqe: %d\\n", ret);
        return 1;
    }

    /* Check the result */
    if (cqe->res < 0) {
        fprintf(stderr, "read failed: %d\\n", cqe->res);
    } else {
        printf("Read %d bytes\\n", cqe->res);
    }

    /* Mark CQE as seen */
    io_uring_cqe_seen(&ring, cqe);

    close(fd);
    io_uring_queue_exit(&ring);
    return 0;
}
.EE
.SS Reading entire file handling short reads
.EX
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <liburing.h>

/*
 * Read entire file, handling short reads.
 */
ssize_t read_file(struct io_uring *ring, int fd, void *buf, size_t len)
{
    struct io_uring_sqe *sqe;
    struct io_uring_cqe *cqe;
    char *ptr = buf;
    size_t remaining = len;
    off_t offset = 0;
    int ret;

    while (remaining > 0) {
        sqe = io_uring_get_sqe(ring);
        io_uring_prep_read(sqe, fd, ptr, remaining, offset);

        io_uring_submit(ring);
        io_uring_wait_cqe(ring, &cqe);

        ret = cqe->res;
        io_uring_cqe_seen(ring, cqe);

        if (ret < 0)
            return ret;  /* Error */
        if (ret == 0)
            break;       /* EOF */

        ptr += ret;
        offset += ret;
        remaining -= ret;
    }

    return len - remaining;
}
.EE
.SS Batch read multiple files
.EX
#include <stdio.h>
#include <fcntl.h>
#include <liburing.h>

struct read_req {
    int fd;
    void *buf;
    size_t len;
    off_t offset;
    int result;
};

/*
 * Read from multiple files in parallel.
 */
int batch_read(struct io_uring *ring, struct read_req *reqs, int count)
{
    struct io_uring_sqe *sqe;
    struct io_uring_cqe *cqe;
    int i, ret;

    /* Queue all read requests */
    for (i = 0; i < count; i++) {
        sqe = io_uring_get_sqe(ring);
        io_uring_prep_read(sqe, reqs[i].fd, reqs[i].buf,
                           reqs[i].len, reqs[i].offset);
        io_uring_sqe_set_data(sqe, &reqs[i]);
    }

    ret = io_uring_submit(ring);
    if (ret < 0)
        return ret;

    /* Collect results */
    for (i = 0; i < count; i++) {
        io_uring_wait_cqe(ring, &cqe);

        struct read_req *req = io_uring_cqe_get_data(cqe);
        req->result = cqe->res;

        io_uring_cqe_seen(ring, cqe);
    }

    return 0;
}
.EE
.SS Read with buffer selection
.EX
#include <stdio.h>
#include <fcntl.h>
#include <liburing.h>

#define BGID     1
#define BUF_SIZE 4096

/*
 * Read using buffer selection from a buffer ring.
 * Kernel picks an available buffer from the pool.
 */
int read_with_buffer_select(struct io_uring *ring, int fd,
                            char **buf_out, off_t offset)
{
    struct io_uring_sqe *sqe;
    struct io_uring_cqe *cqe;
    int ret, bid;

    sqe = io_uring_get_sqe(ring);
    io_uring_prep_read(sqe, fd, NULL, BUF_SIZE, offset);
    sqe->flags |= IOSQE_BUFFER_SELECT;
    sqe->buf_group = BGID;

    io_uring_submit(ring);
    io_uring_wait_cqe(ring, &cqe);

    ret = cqe->res;
    if (ret > 0 && (cqe->flags & IORING_CQE_F_BUFFER)) {
        bid = cqe->flags >> IORING_CQE_BUFFER_SHIFT;
        /* Application maps bid to actual buffer address */
        *buf_out = get_buffer_by_id(bid);
    }

    io_uring_cqe_seen(ring, cqe);
    return ret;
}
.EE
.SS Read with fixed file descriptor
.EX
#include <stdio.h>
#include <liburing.h>

/*
 * Read using a registered (fixed) file descriptor.
 * More efficient for frequent operations on the same file.
 */
int read_fixed_file(struct io_uring *ring, int fixed_fd_index,
                    void *buf, size_t len, off_t offset)
{
    struct io_uring_sqe *sqe;
    struct io_uring_cqe *cqe;
    int ret;

    sqe = io_uring_get_sqe(ring);
    io_uring_prep_read(sqe, fixed_fd_index, buf, len, offset);
    sqe->flags |= IOSQE_FIXED_FILE;

    io_uring_submit(ring);
    io_uring_wait_cqe(ring, &cqe);

    ret = cqe->res;
    io_uring_cqe_seen(ring, cqe);

    return ret;
}
.EE
.SH SEE ALSO
.BR io_uring_get_sqe (3),
.BR io_uring_submit (3),
.BR io_uring_prep_readv (3),
.BR io_uring_prep_write (3),
.BR io_uring_register_files (3),
.BR io_uring_setup_buf_ring (3),
.BR pread (2),
.BR read (2)
