.\" Copyright (C) 2022 Jens Axboe <axboe@kernel.dk>
.\"
.\" SPDX-License-Identifier: LGPL-2.0-or-later
.\"
.TH io_uring_prep_timeout 3 "March 12, 2022" "liburing-2.2" "liburing Manual"
.SH NAME
io_uring_prep_timeout \- prepare a timeout request
.SH SYNOPSIS
.nf
.B #include <liburing.h>
.PP
.BI "void io_uring_prep_timeout(struct io_uring_sqe *" sqe ","
.BI "                           const struct __kernel_timespec *" ts ","
.BI "                           unsigned " count ","
.BI "                           unsigned " flags ");"
.fi
.SH DESCRIPTION
.PP
The
.BR io_uring_prep_timeout (3)
function prepares a timeout request. The submission queue entry
.I sqe
is setup to arm a timeout specified by
.I ts
and with a timeout count of
.I count
completion entries. The
.I flags
argument holds modifier flags for the request.

This request type can be used as a timeout waking anyone sleeping
for events on the CQ ring. The
.I flags
argument may contain:
.TP
.B IORING_TIMEOUT_ABS
The value specified in
.I ts
is an absolute value rather than a relative one.
.TP
.B IORING_TIMEOUT_BOOTTIME
The boottime clock source should be used.
.TP
.B IORING_TIMEOUT_REALTIME
The realtime clock source should be used.
.TP
.B IORING_TIMEOUT_ETIME_SUCCESS
Consider an expired timeout a success in terms of the posted completion. This
means it will not sever dependent links, as a failed request normally would. The
posted CQE result code will still contain
.B -ETIME
in the
.I res
value.
.TP
.B IORING_TIMEOUT_MULTISHOT
The request will return multiple timeout completions. The completion flag
IORING_CQE_F_MORE is set if more timeouts are expected. The value specified in
.I count
is the number of repeats. A value of 0 means the timeout is indefinite and can
only be stopped by a removal request. Available since the 6.4 kernel.
.PP
If no alternate clock source is given in the above flags, then
.B CLOCK_MONOTONIC
is used.

The timeout completion event will trigger if either the specified timeout
has occurred, or the specified number of events to wait for have been posted
to the CQ ring.

.SH RETURN VALUE
None
.SH ERRORS
These are the errors that are reported in the CQE
.I res
field. On success,
.B 0
is returned.
.TP
.B -ETIME
The specified timeout occurred and triggered the completion event.
.TP
.B -EINVAL
One of the fields set in the SQE was invalid. For example, two clocksources
were given, or the specified timeout seconds or nanoseconds were < 0.
.TP
.B -EFAULT
io_uring was unable to access the data specified by
.IR ts .
.TP
.B -ECANCELED
The timeout was canceled by a removal request.
.SH NOTES
As with any request that passes in data in a struct, that data must remain
valid until the request has been successfully submitted. It need not remain
valid until completion. Once a request has been submitted, the in-kernel
state is stable. Very early kernels (5.4 and earlier) required state to be
stable until the completion occurred. Applications can test for this
behavior by inspecting the
.B IORING_FEAT_SUBMIT_STABLE
flag passed back from
.BR io_uring_queue_init_params (3).
.PP
The timeout request is useful for implementing timed waits on the CQ ring.
When using
.BR io_uring_wait_cqe (3)
or similar wait functions, submitting a timeout request beforehand will
cause the wait to return when either a normal CQE arrives or the timeout
expires.
.SH EXAMPLE
.SS Basic timeout
.EX
#include <stdio.h>
#include <liburing.h>

/*
 * Wait for an event with a timeout. Returns 0 if event arrived,
 * -ETIME if timeout expired, or other negative error.
 */
int wait_with_timeout(struct io_uring *ring, struct io_uring_cqe **cqe_ret,
                      int timeout_ms)
{
    struct io_uring_sqe *sqe;
    struct io_uring_cqe *cqe;
    struct __kernel_timespec ts;
    int ret;

    ts.tv_sec = timeout_ms / 1000;
    ts.tv_nsec = (timeout_ms % 1000) * 1000000LL;

    sqe = io_uring_get_sqe(ring);
    io_uring_prep_timeout(sqe, &ts, 0, 0);
    io_uring_sqe_set_data64(sqe, (unsigned long long)-1);  /* Sentinel */

    io_uring_submit(ring);
    io_uring_wait_cqe(ring, &cqe);

    if (io_uring_cqe_get_data64(cqe) == (unsigned long long)-1) {
        /* This is the timeout CQE */
        ret = cqe->res;  /* -ETIME */
        io_uring_cqe_seen(ring, cqe);
        *cqe_ret = NULL;
    } else {
        /* Real event arrived before timeout */
        *cqe_ret = cqe;
        ret = 0;
        /* Caller should call io_uring_cqe_seen() */

        /* Cancel the pending timeout */
        sqe = io_uring_get_sqe(ring);
        io_uring_prep_timeout_remove(sqe, (unsigned long long)-1, 0);
        io_uring_submit(ring);
    }

    return ret;
}
.EE
.SS Timeout with completion count
.EX
#include <stdio.h>
#include <liburing.h>

/*
 * Wait for N events or timeout, whichever comes first.
 */
int wait_for_n_or_timeout(struct io_uring *ring, int count, int timeout_ms)
{
    struct io_uring_sqe *sqe;
    struct io_uring_cqe *cqe;
    struct __kernel_timespec ts;
    int received = 0;

    ts.tv_sec = timeout_ms / 1000;
    ts.tv_nsec = (timeout_ms % 1000) * 1000000LL;

    /* Timeout after 'count' completions OR after timeout_ms */
    sqe = io_uring_get_sqe(ring);
    io_uring_prep_timeout(sqe, &ts, count, 0);
    io_uring_sqe_set_data64(sqe, 0);  /* Timeout marker */

    io_uring_submit(ring);

    while (1) {
        io_uring_wait_cqe(ring, &cqe);

        if (io_uring_cqe_get_data64(cqe) == 0) {
            /* Timeout fired - either time expired or count reached */
            io_uring_cqe_seen(ring, cqe);
            break;
        }

        /* Process real completion */
        printf("Got completion: %d\\n", cqe->res);
        received++;
        io_uring_cqe_seen(ring, cqe);
    }

    return received;
}
.EE
.SS Multishot timeout for periodic events
.EX
#include <stdio.h>
#include <liburing.h>

#define TIMEOUT_DATA 0x12345678

/*
 * Set up a periodic timeout that fires every interval_ms.
 * Continues until canceled or repeat_count reached.
 */
void setup_periodic_timeout(struct io_uring *ring, int interval_ms,
                            int repeat_count)
{
    struct io_uring_sqe *sqe;
    struct __kernel_timespec ts;

    ts.tv_sec = interval_ms / 1000;
    ts.tv_nsec = (interval_ms % 1000) * 1000000LL;

    sqe = io_uring_get_sqe(ring);
    io_uring_prep_timeout(sqe, &ts, repeat_count,
                          IORING_TIMEOUT_MULTISHOT);
    io_uring_sqe_set_data64(sqe, TIMEOUT_DATA);

    io_uring_submit(ring);
}

void event_loop_with_periodic(struct io_uring *ring)
{
    struct io_uring_cqe *cqe;

    /* Set up a timeout that fires every 1 second, 10 times */
    setup_periodic_timeout(ring, 1000, 10);

    while (1) {
        io_uring_wait_cqe(ring, &cqe);

        if (io_uring_cqe_get_data64(cqe) == TIMEOUT_DATA) {
            printf("Periodic timeout fired!\\n");

            if (!(cqe->flags & IORING_CQE_F_MORE)) {
                printf("No more timeouts\\n");
                io_uring_cqe_seen(ring, cqe);
                break;
            }
        } else {
            /* Handle other completions */
            handle_completion(cqe);
        }

        io_uring_cqe_seen(ring, cqe);
    }
}
.EE
.SS Absolute timeout at specific time
.EX
#include <stdio.h>
#include <time.h>
#include <liburing.h>

/*
 * Set a timeout that fires at a specific wall-clock time.
 */
void timeout_at_time(struct io_uring *ring, time_t when)
{
    struct io_uring_sqe *sqe;
    struct __kernel_timespec ts;

    ts.tv_sec = when;
    ts.tv_nsec = 0;

    sqe = io_uring_get_sqe(ring);
    io_uring_prep_timeout(sqe, &ts, 0,
                          IORING_TIMEOUT_ABS | IORING_TIMEOUT_REALTIME);

    io_uring_submit(ring);
}

/* Example: timeout at midnight */
void timeout_at_midnight(struct io_uring *ring)
{
    time_t now = time(NULL);
    struct tm *tm = localtime(&now);

    /* Calculate seconds until midnight */
    tm->tm_hour = 0;
    tm->tm_min = 0;
    tm->tm_sec = 0;
    tm->tm_mday++;  /* Next day */

    timeout_at_time(ring, mktime(tm));
}
.EE
.SH SEE ALSO
.BR io_uring_get_sqe (3),
.BR io_uring_submit (3),
.BR io_uring_wait_cqe (3),
.BR io_uring_prep_timeout_remove (3),
.BR io_uring_prep_timeout_update (3),
.BR io_uring_prep_link_timeout (3)
