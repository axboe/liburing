.\" Copyright (C) 2022 Jens Axboe <axboe@kernel.dk>
.\"
.\" SPDX-License-Identifier: LGPL-2.0-or-later
.\"
.TH io_uring_prep_symlinkat 3 "March 13, 2022" "liburing-2.2" "liburing Manual"
.SH NAME
io_uring_prep_symlinkat \- prepare a symlinkat request
.SH SYNOPSIS
.nf
.B #include <fcntl.h>
.B #include <unistd.h>
.B #include <liburing.h>
.PP
.BI "void io_uring_prep_symlinkat(struct io_uring_sqe *" sqe ","
.BI "                             const char *" target ","
.BI "                             int " newdirfd ","
.BI "                             const char *" linkpath ");"
.PP
.BI "void io_uring_prep_symlink(struct io_uring_sqe *" sqe ","
.BI "                           const char *" target ","
.BI "                           const char *" linkpath ");"
.fi
.SH DESCRIPTION
.PP
The
.BR io_uring_prep_symlinkat (3)
function prepares a symlinkat request. The submission queue entry
.I sqe
is setup to symlink the target path pointed to by
.I target
to the new destination indicated by
.I newdirfd
and
.IR linkpath .

The
.BR io_uring_prep_symlink (3)
function prepares a symlink request. The submission queue entry
.I sqe
is setup to symlink the target path pointed to by
.I target
to the new destination indicated by
.I linkpath
relative to the current working directory. This function prepares an async
.BR symlink (2)
request. See that man page for details.

These functions prepare an async
.BR symlinkat (2)
or
.BR symlink (2)
request. See those man pages for details.

.SH RETURN VALUE
None
.SH ERRORS
The CQE
.I res
field will contain the result of the operation. On success, it contains
.BR 0 .
On error, it contains the negated
.I errno
value.
.PP
Common errors include:
.TP
.B -EEXIST
The link path already exists.
.TP
.B -ENOENT
A component of the link path prefix does not exist.
.TP
.B -EACCES
Permission denied.
.TP
.B -ENOTDIR
A component of the path prefix is not a directory.
.TP
.B -ENAMETOOLONG
The target or link path is too long.
.TP
.B -ENOSPC
No space left on device.
.TP
.B -EROFS
The filesystem is read-only.
.SH NOTES
As with any request that passes in data in a struct, that data must remain
valid until the request has been successfully submitted. It need not remain
valid until completion. Once a request has been submitted, the in-kernel
state is stable. Very early kernels (5.4 and earlier) required state to be
stable until the completion occurred. Applications can test for this
behavior by inspecting the
.B IORING_FEAT_SUBMIT_STABLE
flag passed back from
.BR io_uring_queue_init_params (3).
.PP
The
.I target
is the path the symbolic link will point to. It can be an absolute path or
a relative path. If relative, it is relative to the location of the symbolic
link itself, not the current working directory.
.SH EXAMPLE
.SS Create a symbolic link
.EX
#include <stdio.h>
#include <fcntl.h>
#include <liburing.h>

int create_symlink(struct io_uring *ring,
                   const char *target, const char *linkpath)
{
    struct io_uring_sqe *sqe;
    struct io_uring_cqe *cqe;
    int ret;

    sqe = io_uring_get_sqe(ring);
    io_uring_prep_symlink(sqe, target, linkpath);

    io_uring_submit(ring);
    io_uring_wait_cqe(ring, &cqe);

    ret = cqe->res;
    io_uring_cqe_seen(ring, cqe);

    if (ret < 0)
        fprintf(stderr, "symlink failed: %d\\n", ret);

    return ret;
}
.EE
.SS Create symlink relative to directory
.EX
#include <stdio.h>
#include <fcntl.h>
#include <liburing.h>

/*
 * Create a symbolic link in a specific directory.
 */
int create_symlink_in_dir(struct io_uring *ring, int dirfd,
                          const char *target, const char *linkname)
{
    struct io_uring_sqe *sqe;
    struct io_uring_cqe *cqe;
    int ret;

    sqe = io_uring_get_sqe(ring);
    io_uring_prep_symlinkat(sqe, target, dirfd, linkname);

    io_uring_submit(ring);
    io_uring_wait_cqe(ring, &cqe);

    ret = cqe->res;
    io_uring_cqe_seen(ring, cqe);

    return ret;
}
.EE
.SS Create symlink or update if exists
.EX
#include <stdio.h>
#include <fcntl.h>
#include <liburing.h>

/*
 * Create symlink, removing existing link if present.
 */
int force_symlink(struct io_uring *ring,
                  const char *target, const char *linkpath)
{
    struct io_uring_sqe *sqe;
    struct io_uring_cqe *cqe;
    int ret;

    /* Try to create symlink */
    sqe = io_uring_get_sqe(ring);
    io_uring_prep_symlink(sqe, target, linkpath);

    io_uring_submit(ring);
    io_uring_wait_cqe(ring, &cqe);

    ret = cqe->res;
    io_uring_cqe_seen(ring, cqe);

    if (ret == -EEXIST) {
        /* Remove existing and retry */
        sqe = io_uring_get_sqe(ring);
        io_uring_prep_unlink(sqe, linkpath, 0);
        io_uring_submit(ring);
        io_uring_wait_cqe(ring, &cqe);
        io_uring_cqe_seen(ring, cqe);

        sqe = io_uring_get_sqe(ring);
        io_uring_prep_symlink(sqe, target, linkpath);
        io_uring_submit(ring);
        io_uring_wait_cqe(ring, &cqe);

        ret = cqe->res;
        io_uring_cqe_seen(ring, cqe);
    }

    return ret;
}
.EE
.SS Batch create multiple symlinks
.EX
#include <stdio.h>
#include <fcntl.h>
#include <liburing.h>

struct symlink_op {
    const char *target;
    const char *linkpath;
};

int batch_symlink(struct io_uring *ring,
                  struct symlink_op *ops, int count)
{
    struct io_uring_sqe *sqe;
    struct io_uring_cqe *cqe;
    int i, ret, errors = 0;

    /* Queue all symlink requests */
    for (i = 0; i < count; i++) {
        sqe = io_uring_get_sqe(ring);
        io_uring_prep_symlink(sqe, ops[i].target, ops[i].linkpath);
        io_uring_sqe_set_data64(sqe, i);
    }

    ret = io_uring_submit(ring);
    if (ret < 0)
        return ret;

    /* Collect results */
    for (i = 0; i < count; i++) {
        io_uring_wait_cqe(ring, &cqe);

        if (cqe->res < 0) {
            int idx = io_uring_cqe_get_data64(cqe);
            fprintf(stderr, "symlink %s -> %s failed: %d\\n",
                    ops[idx].linkpath, ops[idx].target, cqe->res);
            errors++;
        }

        io_uring_cqe_seen(ring, cqe);
    }

    return errors ? -1 : 0;
}
.EE
.SH SEE ALSO
.BR io_uring_get_sqe (3),
.BR io_uring_submit (3),
.BR io_uring_prep_linkat (3),
.BR io_uring_prep_unlinkat (3),
.BR symlinkat (2),
.BR symlink (2)
