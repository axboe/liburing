.\" Copyright (C) 2022 Jens Axboe <axboe@kernel.dk>
.\"
.\" SPDX-License-Identifier: LGPL-2.0-or-later
.\"
.TH io_uring_prep_cancel 3 "March 12, 2022" "liburing-2.2" "liburing Manual"
.SH NAME
io_uring_prep_cancel \- prepare a cancelation request
.SH SYNOPSIS
.nf
.B #include <liburing.h>
.PP
.BI "void io_uring_prep_cancel64(struct io_uring_sqe *" sqe ","
.BI "                            __u64 " user_data ","
.BI "                            int " flags ");"
.PP
.BI "void io_uring_prep_cancel(struct io_uring_sqe *" sqe ","
.BI "                          const void *" user_data ","
.BI "                          int " flags ");"
.PP
.BI "void io_uring_prep_cancel_fd(struct io_uring_sqe *" sqe ","
.BI "                          int " fd ","
.BI "                          unsigned int " flags ");"
.fi
.SH DESCRIPTION
.PP
The
.BR io_uring_prep_cancel (3)
function prepares a cancelation request. The submission queue entry
.I sqe
is prepared to cancel an existing request identified by
.IR user_data .
For the
.I flags
argument, see below.

.BR io_uring_prep_cancel64 (3)
is identical to
.BR io_uring_prep_cancel (3) ,
except it takes a 64-bit integer rather than a pointer type.

The cancelation request will attempt to find the previously issued request
identified by
.I user_data
and cancel it. The identifier is what the previously issued request has in
their
.I user_data
field in the SQE.

The
.BR io_uring_prep_cancel_fd (3)
function prepares a cancelation request. The submission queue entry
.I sqe
is prepared to cancel an existing request that used the file descriptor
.IR fd .
For the
.I flags
argument, see below.

The cancelation request will attempt to find the previously issued request
that used
.I fd
as the file descriptor and cancel it.

By default, the first request matching the criteria given will be canceled.
This can be modified with any of the following flags passed in:
.TP
.B IORING_ASYNC_CANCEL_ALL
Cancel all requests that match the given criteria, rather than just canceling
the first one found. Available since 5.19.
.TP
.B IORING_ASYNC_CANCEL_FD
Match based on the file descriptor used in the original request rather than
the user_data. This is what
.BR io_uring_prep_cancel_fd (3)
sets up. Available since 5.19.
.TP
.B IORING_ASYNC_CANCEL_FD_FIXED
Set in conjunction with
.B IORING_ASYNC_CANCEL_FD ,
indicating that the file descriptor given is a direct descriptor rather than
a normal file descriptor. Available since 6.0.
.TP
.B IORING_ASYNC_CANCEL_ANY
Match any request in the ring, regardless of user_data or file descriptor.
Can be used to cancel any pending request in the ring. Available since 5.19.
.TP
.B IORING_ASYNC_CANCEL_USERDATA
Match request based on the user data field set in the original request. This
is the default lookup key, if no other key matching has been specified.
Available since 6.6.
.TP
.B IORING_ASYNC_CANCEL_OP
Use the original request opcode as the matching key. The opcopde requested
must be set in the sqe
.I len
field after using one of the generic cancel preparation helpers. Available
since 6.6.
.P

.SH RETURN VALUE
None
.SH ERRORS
These are the errors that are reported in the CQE
.I res
field. If no flags are used to cancel multiple requests,
.B 0
is returned on success. If flags are used to match multiple requests, then
a positive value is returned indicating how many requests were found and
canceled.
.TP
.B -ENOENT
The request identified by
.I user_data
could not be located. This could be because it completed before the cancelation
request was issued, or if an invalid identifier is used.
.TP
.B -EINVAL
One of the fields set in the SQE was invalid.
.TP
.B -EALREADY
The execution state of the request has progressed far enough that cancelation
is no longer possible. This should normally mean that it will complete shortly,
either successfully, or interrupted due to the cancelation.
.SH NOTES
Although the cancelation request uses async request syntax, the kernel side of
the cancelation is always run synchronously. It is guaranteed that a CQE is
always generated by the time the cancel request has been submitted. If the
cancelation is successful, the completion for the request targeted for
cancelation will have been posted by the time submission returns. For
.B -EALREADY
it may take a bit of time to do so. For this case, the caller must wait for the
canceled request to post its completion event.
.PP
When a request is successfully canceled, it will complete with
.B -ECANCELED
in its CQE
.I res
field.
.SH EXAMPLE
.SS Basic cancelation by user_data
.EX
#include <stdio.h>
#include <liburing.h>

#define READ_OP_ID  0x1234

int start_read(struct io_uring *ring, int fd, void *buf, size_t len)
{
    struct io_uring_sqe *sqe;

    sqe = io_uring_get_sqe(ring);
    io_uring_prep_read(sqe, fd, buf, len, 0);
    io_uring_sqe_set_data64(sqe, READ_OP_ID);

    return io_uring_submit(ring);
}

int cancel_read(struct io_uring *ring)
{
    struct io_uring_sqe *sqe;
    struct io_uring_cqe *cqe;
    int ret;

    sqe = io_uring_get_sqe(ring);
    io_uring_prep_cancel64(sqe, READ_OP_ID, 0);
    io_uring_sqe_set_data64(sqe, 0);  /* Cancel request ID */

    ret = io_uring_submit(ring);
    if (ret < 0)
        return ret;

    /* The cancel CQE is always ready after submit */
    io_uring_wait_cqe(ring, &cqe);

    if (cqe->res == 0) {
        printf("Request canceled successfully\\n");
    } else if (cqe->res == -ENOENT) {
        printf("Request not found (already completed?)\\n");
    } else if (cqe->res == -EALREADY) {
        printf("Request in progress, will complete soon\\n");
    }

    ret = cqe->res;
    io_uring_cqe_seen(ring, cqe);

    return ret;
}
.EE
.SS Cancel all requests matching user_data
.EX
#include <stdio.h>
#include <liburing.h>

#define BATCH_OP_ID 0xBATCH

/*
 * Submit multiple reads with the same user_data identifier.
 */
void submit_batch_reads(struct io_uring *ring, int *fds, void **bufs,
                        size_t len, int count)
{
    struct io_uring_sqe *sqe;
    int i;

    for (i = 0; i < count; i++) {
        sqe = io_uring_get_sqe(ring);
        io_uring_prep_read(sqe, fds[i], bufs[i], len, 0);
        io_uring_sqe_set_data64(sqe, BATCH_OP_ID);
    }

    io_uring_submit(ring);
}

/*
 * Cancel all reads submitted with BATCH_OP_ID.
 */
int cancel_all_batch_reads(struct io_uring *ring)
{
    struct io_uring_sqe *sqe;
    struct io_uring_cqe *cqe;
    int ret;

    sqe = io_uring_get_sqe(ring);
    io_uring_prep_cancel64(sqe, BATCH_OP_ID, IORING_ASYNC_CANCEL_ALL);

    io_uring_submit(ring);
    io_uring_wait_cqe(ring, &cqe);

    if (cqe->res > 0) {
        printf("Canceled %d requests\\n", cqe->res);
    } else if (cqe->res == -ENOENT) {
        printf("No matching requests found\\n");
    }

    ret = cqe->res;
    io_uring_cqe_seen(ring, cqe);

    return ret;
}
.EE
.SS Cancel all requests on a file descriptor
.EX
#include <stdio.h>
#include <liburing.h>

/*
 * Cancel all pending operations on a specific file descriptor.
 * Useful when closing a connection or file.
 */
int cancel_all_on_fd(struct io_uring *ring, int fd)
{
    struct io_uring_sqe *sqe;
    struct io_uring_cqe *cqe;
    int ret;

    sqe = io_uring_get_sqe(ring);
    io_uring_prep_cancel_fd(sqe, fd,
                            IORING_ASYNC_CANCEL_FD | IORING_ASYNC_CANCEL_ALL);

    io_uring_submit(ring);
    io_uring_wait_cqe(ring, &cqe);

    if (cqe->res > 0)
        printf("Canceled %d requests on fd %d\\n", cqe->res, fd);

    ret = cqe->res;
    io_uring_cqe_seen(ring, cqe);

    return ret;
}

/*
 * Clean shutdown of a socket: cancel pending operations,
 * then close.
 */
void shutdown_socket(struct io_uring *ring, int sockfd)
{
    struct io_uring_sqe *sqe;
    struct io_uring_cqe *cqe;
    unsigned head;
    int canceled;

    /* First, cancel all pending operations */
    canceled = cancel_all_on_fd(ring, sockfd);

    /* Wait for canceled operations to complete with -ECANCELED */
    if (canceled > 0) {
        int remaining = canceled;
        while (remaining > 0) {
            io_uring_wait_cqe(ring, &cqe);
            if (cqe->res == -ECANCELED)
                remaining--;
            io_uring_cqe_seen(ring, cqe);
        }
    }

    /* Now safe to close */
    sqe = io_uring_get_sqe(ring);
    io_uring_prep_close(sqe, sockfd);
    io_uring_submit(ring);
}
.EE
.SS Cancel any pending request
.EX
#include <stdio.h>
#include <liburing.h>

/*
 * Emergency cancel: abort all pending operations.
 * Useful for shutdown or error recovery.
 */
int cancel_everything(struct io_uring *ring)
{
    struct io_uring_sqe *sqe;
    struct io_uring_cqe *cqe;
    int total = 0;

    /* Keep canceling until no more requests found */
    while (1) {
        sqe = io_uring_get_sqe(ring);
        io_uring_prep_cancel64(sqe, 0, IORING_ASYNC_CANCEL_ANY);

        io_uring_submit(ring);
        io_uring_wait_cqe(ring, &cqe);

        if (cqe->res == -ENOENT) {
            /* No more requests to cancel */
            io_uring_cqe_seen(ring, cqe);
            break;
        }

        if (cqe->res >= 0)
            total += (cqe->res > 0) ? cqe->res : 1;

        io_uring_cqe_seen(ring, cqe);
    }

    printf("Canceled %d total requests\\n", total);
    return total;
}
.EE
.SH SEE ALSO
.BR io_uring_prep_poll_remove (3),
.BR io_uring_prep_timeout_remove (3),
.BR io_uring_get_sqe (3),
.BR io_uring_submit (3)
