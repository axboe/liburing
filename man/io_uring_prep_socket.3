.\" Copyright (C) 2022 Jens Axboe <axboe@kernel.dk>
.\"
.\" SPDX-License-Identifier: LGPL-2.0-or-later
.\"
.TH io_uring_prep_socket 3 "May 27, 2022" "liburing-2.2" "liburing Manual"
.SH NAME
io_uring_prep_socket \- prepare a socket creation request
.SH SYNOPSIS
.nf
.B #include <sys/socket.h>
.B #include <liburing.h>
.PP
.BI "void io_uring_prep_socket(struct io_uring_sqe *" sqe ","
.BI "                          int " domain ","
.BI "                          int " type ","
.BI "                          int " protocol ","
.BI "                          unsigned int " flags ");"
.PP
.BI "void io_uring_prep_socket_direct(struct io_uring_sqe *" sqe ","
.BI "                                 int " domain ","
.BI "                                 int " type ","
.BI "                                 int " protocol ","
.BI "                                 unsigned int " file_index ","
.BI "                                 unsigned int " flags ");"
.PP
.BI "void io_uring_prep_socket_direct_alloc(struct io_uring_sqe *" sqe ","
.BI "                                 int " domain ","
.BI "                                 int " type ","
.BI "                                 int " protocol ","
.BI "                                 unsigned int " flags ");"
.fi
.SH DESCRIPTION
.PP
The
.BR io_uring_prep_socket (3)
function prepares a socket creation request. The submission queue entry
.I sqe
is setup to use the communication domain defined by
.I domain
and use the communication type defined by
.I type
and the protocol set by
.IR protocol .
The
.I flags
argument are currently unused.
.PP
Common values for
.I domain
include
.B AF_INET
for IPv4,
.B AF_INET6
for IPv6, and
.B AF_UNIX
for Unix domain sockets.
.PP
Common values for
.I type
include
.B SOCK_STREAM
for TCP and
.B SOCK_DGRAM
for UDP.
.PP
The
.BR io_uring_prep_socket_direct (3)
helper works just like
.BR io_uring_prep_socket (3),
except it maps the socket to a direct descriptor rather than return a normal
file descriptor. The
.I file_index
argument should be set to the slot that should be used for this socket.
.PP
The
.BR io_uring_prep_socket_direct_alloc (3)
helper works just like
.BR io_uring_prep_socket_direct (3),
except it allocates a new direct descriptor rather than pass a free slot in. It
is equivalent to using
.BR io_uring_prep_socket_direct (3)
with
.B IORING_FILE_INDEX_ALLOC
as the
.I file_index .
Upon completion, the
.I res
field of the CQE will return the direct slot that was allocated for the
socket.
.PP
If the direct variants are used, the application must first have registered
a file table using
.BR io_uring_register_files (3)
of the appropriate size. Once registered, a direct socket request may use any
entry in that table, as long as it is within the size of the registered table.
If a specified entry already contains a file, the file will first be removed
from the table and closed. It's consistent with the behavior of updating an
existing file with
.BR io_uring_register_files_update (3).
.PP
For a direct descriptor socket request, the
.I file_index
argument can be set to
.BR IORING_FILE_INDEX_ALLOC ,
In this case a free entry in io_uring file table will
be used automatically and the file index will be returned as CQE
.IR res .
.B -ENFILE
is otherwise returned if there is no free entries in the io_uring file table.
.PP
These functions prepare an async
.BR socket (2)
request. See that man page for details.
.SH RETURN VALUE
None
.SH ERRORS
The CQE
.I res
field will contain the result of the operation. On success, it contains
the file descriptor of the created socket (or the direct descriptor slot
for direct variants). On failure, it contains the negated
.I errno
value.
.PP
Common errors include:
.TP
.B -EAFNOSUPPORT
The specified address family is not supported.
.TP
.B -EPROTONOSUPPORT
The protocol is not supported within the specified domain.
.TP
.B -EMFILE
The per-process file descriptor limit has been reached.
.TP
.B -ENFILE
For direct variants, no free slot in the registered file table.
.SH EXAMPLE
.SS Creating a TCP socket
.EX
#include <stdio.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <liburing.h>

int create_tcp_socket(struct io_uring *ring)
{
    struct io_uring_sqe *sqe;
    struct io_uring_cqe *cqe;
    int ret;

    sqe = io_uring_get_sqe(ring);
    io_uring_prep_socket(sqe, AF_INET, SOCK_STREAM, 0, 0);

    ret = io_uring_submit(ring);
    if (ret < 0)
        return ret;

    ret = io_uring_wait_cqe(ring, &cqe);
    if (ret < 0)
        return ret;

    ret = cqe->res;  /* fd on success, -errno on failure */
    io_uring_cqe_seen(ring, cqe);

    return ret;
}
.EE
.SS TCP client connection flow
.EX
#include <stdio.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <liburing.h>

enum { OP_SOCKET, OP_CONNECT, OP_SEND };

int tcp_client(struct io_uring *ring, const char *host, int port)
{
    struct io_uring_sqe *sqe;
    struct io_uring_cqe *cqe;
    struct sockaddr_in addr;
    int fd, ret;

    /* Create socket */
    sqe = io_uring_get_sqe(ring);
    io_uring_prep_socket(sqe, AF_INET, SOCK_STREAM, 0, 0);
    io_uring_sqe_set_data64(sqe, OP_SOCKET);
    io_uring_submit(ring);

    io_uring_wait_cqe(ring, &cqe);
    if (cqe->res < 0) {
        fprintf(stderr, "socket: %d\\n", cqe->res);
        return cqe->res;
    }
    fd = cqe->res;
    io_uring_cqe_seen(ring, cqe);

    /* Connect */
    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    inet_pton(AF_INET, host, &addr.sin_addr);

    sqe = io_uring_get_sqe(ring);
    io_uring_prep_connect(sqe, fd, (struct sockaddr *)&addr, sizeof(addr));
    io_uring_sqe_set_data64(sqe, OP_CONNECT);
    io_uring_submit(ring);

    io_uring_wait_cqe(ring, &cqe);
    ret = cqe->res;
    io_uring_cqe_seen(ring, cqe);

    if (ret < 0) {
        fprintf(stderr, "connect: %d\\n", ret);
        close(fd);
        return ret;
    }

    printf("Connected to %s:%d\\n", host, port);
    return fd;
}
.EE
.SS Creating a direct descriptor socket
.EX
#include <stdio.h>
#include <sys/socket.h>
#include <liburing.h>

#define FILE_TABLE_SIZE 64

/*
 * Create socket as a direct descriptor to avoid
 * fd table lookups on subsequent operations.
 */
int create_direct_socket(struct io_uring *ring, int slot)
{
    struct io_uring_sqe *sqe;
    struct io_uring_cqe *cqe;
    int ret;

    sqe = io_uring_get_sqe(ring);
    io_uring_prep_socket_direct(sqe, AF_INET, SOCK_STREAM, 0,
                                 slot, 0);

    io_uring_submit(ring);
    io_uring_wait_cqe(ring, &cqe);

    ret = cqe->res;
    io_uring_cqe_seen(ring, cqe);

    if (ret < 0)
        fprintf(stderr, "socket_direct failed: %d\\n", ret);

    return ret;  /* 0 on success for direct socket */
}

/*
 * Initialize ring with file table for direct descriptors.
 */
int init_ring_with_files(struct io_uring *ring)
{
    int ret;

    ret = io_uring_queue_init(32, ring, 0);
    if (ret < 0)
        return ret;

    /* Register file table with sparse entries */
    ret = io_uring_register_files_sparse(ring, FILE_TABLE_SIZE);
    if (ret < 0) {
        io_uring_queue_exit(ring);
        return ret;
    }

    return 0;
}
.EE
.SS Auto-allocate direct descriptor slot
.EX
#include <stdio.h>
#include <sys/socket.h>
#include <liburing.h>

/*
 * Create socket with auto-allocated direct descriptor slot.
 * Returns the allocated slot index on success.
 */
int create_socket_auto_slot(struct io_uring *ring)
{
    struct io_uring_sqe *sqe;
    struct io_uring_cqe *cqe;
    int ret;

    sqe = io_uring_get_sqe(ring);
    io_uring_prep_socket_direct_alloc(sqe, AF_INET, SOCK_STREAM, 0, 0);

    io_uring_submit(ring);
    io_uring_wait_cqe(ring, &cqe);

    ret = cqe->res;
    io_uring_cqe_seen(ring, cqe);

    if (ret >= 0)
        printf("Socket created at slot %d\\n", ret);
    else
        fprintf(stderr, "socket_direct_alloc failed: %d\\n", ret);

    return ret;  /* slot index on success, -errno on failure */
}
.EE
.SS UDP socket creation
.EX
#include <stdio.h>
#include <sys/socket.h>
#include <liburing.h>

int create_udp_socket(struct io_uring *ring, int ipv6)
{
    struct io_uring_sqe *sqe;
    struct io_uring_cqe *cqe;
    int domain = ipv6 ? AF_INET6 : AF_INET;
    int ret;

    sqe = io_uring_get_sqe(ring);
    io_uring_prep_socket(sqe, domain, SOCK_DGRAM, 0, 0);

    io_uring_submit(ring);
    io_uring_wait_cqe(ring, &cqe);

    ret = cqe->res;
    io_uring_cqe_seen(ring, cqe);

    return ret;
}
.EE
.SS Unix domain socket
.EX
#include <stdio.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <liburing.h>

int create_unix_socket(struct io_uring *ring, int type)
{
    struct io_uring_sqe *sqe;
    struct io_uring_cqe *cqe;
    int ret;

    /* type: SOCK_STREAM or SOCK_DGRAM */
    sqe = io_uring_get_sqe(ring);
    io_uring_prep_socket(sqe, AF_UNIX, type, 0, 0);

    io_uring_submit(ring);
    io_uring_wait_cqe(ring, &cqe);

    ret = cqe->res;
    io_uring_cqe_seen(ring, cqe);

    return ret;
}
.EE
.SH NOTES
Using direct descriptors for sockets can improve performance by avoiding
file descriptor table lookups on each I/O operation. This is especially
beneficial for high-frequency networking operations.
.PP
Direct descriptor sockets work well with other direct descriptor operations like
.BR io_uring_prep_accept_direct (3)
for accepting connections into direct descriptor slots.
.PP
The
.B SOCK_NONBLOCK
and
.B SOCK_CLOEXEC
flags can be OR'd into the
.I type
parameter, just like with
.BR socket (2).
.SH SEE ALSO
.BR io_uring_get_sqe (3),
.BR io_uring_submit (3),
.BR io_uring_prep_connect (3),
.BR io_uring_prep_accept (3),
.BR io_uring_register_files (3),
.BR socket (2)
